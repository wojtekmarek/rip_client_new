{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _JSON$stringify from \"core-js-pure/stable/json/stringify.js\";\nimport _filterInstanceProperty from \"core-js-pure/stable/instance/filter.js\";\nimport _sliceInstanceProperty from \"core-js-pure/stable/instance/slice.js\";\nexport var CACHE_PREFIX = 'react-avatar/';\nexport var CACHE_KEY_FAILING = 'failing';\nvar _hasLocalStorage = function isLocalStorageAvailable() {\n  try {\n    return 'localStorage' in window && window['localStorage'];\n  } catch (err) {\n    return false;\n  }\n}();\nexport var Cache = /*#__PURE__*/function () {\n  function Cache() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Cache);\n    var _options$cachePrefix = options.cachePrefix,\n      cachePrefix = _options$cachePrefix === void 0 ? CACHE_PREFIX : _options$cachePrefix,\n      _options$sourceTTL = options.sourceTTL,\n      sourceTTL = _options$sourceTTL === void 0 ? 7 * 24 * 3600 * 1000 : _options$sourceTTL,\n      _options$sourceSize = options.sourceSize,\n      sourceSize = _options$sourceSize === void 0 ? 20 : _options$sourceSize;\n    this.cachePrefix = cachePrefix;\n    this.sourceTTL = sourceTTL;\n    this.sourceSize = sourceSize;\n  }\n  _createClass(Cache, [{\n    key: \"set\",\n    value: function set(key, value) {\n      // cache not available\n      if (!_hasLocalStorage) return;\n      value = _JSON$stringify(value);\n      try {\n        localStorage.setItem(this.cachePrefix + key, value);\n      } catch (e) {\n        // failsafe for mobile Safari private mode\n        console.error(e); // eslint-disable-line no-console\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      // cache not available\n      if (!_hasLocalStorage) return null;\n      var value = localStorage.getItem(this.cachePrefix + key);\n      if (value) return JSON.parse(value);\n      return null;\n    }\n  }, {\n    key: \"sourceFailed\",\n    value: function sourceFailed(source) {\n      var cacheList = this.get(CACHE_KEY_FAILING) || []; // Remove expired entries or previous instances of this source\n\n      cacheList = _filterInstanceProperty(cacheList).call(cacheList, function (entry) {\n        var hasExpired = entry.expires > 0 && entry.expires < Date.now();\n        var isMatch = entry === source || entry.url == source;\n        return !hasExpired && !isMatch;\n      }); // Add the source to the end of the list\n\n      cacheList.unshift({\n        url: source,\n        expires: Date.now() + this.sourceTTL\n      }); // only keep the last X results so we don't fill up local storage\n\n      cacheList = _sliceInstanceProperty(cacheList).call(cacheList, 0, this.sourceSize - 1);\n      return this.set(CACHE_KEY_FAILING, cacheList);\n    }\n  }, {\n    key: \"hasSourceFailedBefore\",\n    value: function hasSourceFailedBefore(source) {\n      var cacheList = this.get(CACHE_KEY_FAILING) || [];\n      return cacheList.some(function (entry) {\n        var hasExpired = entry.expires > 0 && entry.expires < Date.now();\n        var isMatch = entry === source || entry.url == source;\n        return isMatch && !hasExpired;\n      });\n    }\n  }]);\n  return Cache;\n}();\nexport default new Cache();","map":null,"metadata":{},"sourceType":"module"}